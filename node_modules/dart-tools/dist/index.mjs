import axios from 'axios';
import FormData from 'form-data';

class ApiError extends Error {
    constructor(request, response, message) {
        super(message);
        this.name = "ApiError";
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.body = response.body;
        this.request = request;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var _CancelablePromise_isResolved, _CancelablePromise_isRejected, _CancelablePromise_isCancelled, _CancelablePromise_cancelHandlers, _CancelablePromise_promise, _CancelablePromise_resolve, _CancelablePromise_reject;
/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
class CancelError extends Error {
    constructor(message) {
        super(message);
        this.name = "CancelError";
    }
    get isCancelled() {
        return true;
    }
}
class CancelablePromise {
    constructor(executor) {
        _CancelablePromise_isResolved.set(this, void 0);
        _CancelablePromise_isRejected.set(this, void 0);
        _CancelablePromise_isCancelled.set(this, void 0);
        _CancelablePromise_cancelHandlers.set(this, void 0);
        _CancelablePromise_promise.set(this, void 0);
        _CancelablePromise_resolve.set(this, void 0);
        _CancelablePromise_reject.set(this, void 0);
        __classPrivateFieldSet(this, _CancelablePromise_isResolved, false, "f");
        __classPrivateFieldSet(this, _CancelablePromise_isRejected, false, "f");
        __classPrivateFieldSet(this, _CancelablePromise_isCancelled, false, "f");
        __classPrivateFieldSet(this, _CancelablePromise_cancelHandlers, [], "f");
        __classPrivateFieldSet(this, _CancelablePromise_promise, new Promise((resolve, reject) => {
            __classPrivateFieldSet(this, _CancelablePromise_resolve, resolve, "f");
            __classPrivateFieldSet(this, _CancelablePromise_reject, reject, "f");
            const onResolve = (value) => {
                if (__classPrivateFieldGet(this, _CancelablePromise_isResolved, "f") || __classPrivateFieldGet(this, _CancelablePromise_isRejected, "f") || __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f")) {
                    return;
                }
                __classPrivateFieldSet(this, _CancelablePromise_isResolved, true, "f");
                if (__classPrivateFieldGet(this, _CancelablePromise_resolve, "f"))
                    __classPrivateFieldGet(this, _CancelablePromise_resolve, "f").call(this, value);
            };
            const onReject = (reason) => {
                if (__classPrivateFieldGet(this, _CancelablePromise_isResolved, "f") || __classPrivateFieldGet(this, _CancelablePromise_isRejected, "f") || __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f")) {
                    return;
                }
                __classPrivateFieldSet(this, _CancelablePromise_isRejected, true, "f");
                if (__classPrivateFieldGet(this, _CancelablePromise_reject, "f"))
                    __classPrivateFieldGet(this, _CancelablePromise_reject, "f").call(this, reason);
            };
            const onCancel = (cancelHandler) => {
                if (__classPrivateFieldGet(this, _CancelablePromise_isResolved, "f") || __classPrivateFieldGet(this, _CancelablePromise_isRejected, "f") || __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f")) {
                    return;
                }
                __classPrivateFieldGet(this, _CancelablePromise_cancelHandlers, "f").push(cancelHandler);
            };
            Object.defineProperty(onCancel, "isResolved", {
                get: () => __classPrivateFieldGet(this, _CancelablePromise_isResolved, "f"),
            });
            Object.defineProperty(onCancel, "isRejected", {
                get: () => __classPrivateFieldGet(this, _CancelablePromise_isRejected, "f"),
            });
            Object.defineProperty(onCancel, "isCancelled", {
                get: () => __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f"),
            });
            return executor(onResolve, onReject, onCancel);
        }), "f");
    }
    get [(_CancelablePromise_isResolved = new WeakMap(), _CancelablePromise_isRejected = new WeakMap(), _CancelablePromise_isCancelled = new WeakMap(), _CancelablePromise_cancelHandlers = new WeakMap(), _CancelablePromise_promise = new WeakMap(), _CancelablePromise_resolve = new WeakMap(), _CancelablePromise_reject = new WeakMap(), Symbol.toStringTag)]() {
        return "Cancellable Promise";
    }
    then(onFulfilled, onRejected) {
        return __classPrivateFieldGet(this, _CancelablePromise_promise, "f").then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return __classPrivateFieldGet(this, _CancelablePromise_promise, "f").catch(onRejected);
    }
    finally(onFinally) {
        return __classPrivateFieldGet(this, _CancelablePromise_promise, "f").finally(onFinally);
    }
    cancel() {
        if (__classPrivateFieldGet(this, _CancelablePromise_isResolved, "f") || __classPrivateFieldGet(this, _CancelablePromise_isRejected, "f") || __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f")) {
            return;
        }
        __classPrivateFieldSet(this, _CancelablePromise_isCancelled, true, "f");
        if (__classPrivateFieldGet(this, _CancelablePromise_cancelHandlers, "f").length) {
            try {
                for (const cancelHandler of __classPrivateFieldGet(this, _CancelablePromise_cancelHandlers, "f")) {
                    cancelHandler();
                }
            }
            catch (error) {
                console.warn("Cancellation threw an error", error);
                return;
            }
        }
        __classPrivateFieldGet(this, _CancelablePromise_cancelHandlers, "f").length = 0;
        if (__classPrivateFieldGet(this, _CancelablePromise_reject, "f"))
            __classPrivateFieldGet(this, _CancelablePromise_reject, "f").call(this, new CancelError("Request aborted"));
    }
    get isCancelled() {
        return __classPrivateFieldGet(this, _CancelablePromise_isCancelled, "f");
    }
}

var _a;
const OpenAPI = {
    BASE: `${(_a = process.env.DART_HOST) !== null && _a !== void 0 ? _a : "https://app.itsdart.com"}/api/v0/public`,
    VERSION: "1.0.0",
    WITH_CREDENTIALS: false,
    CREDENTIALS: "include",
    TOKEN: undefined,
    USERNAME: undefined,
    PASSWORD: undefined,
    HEADERS: { Authorization: `Bearer ${process.env.DART_TOKEN}` },
    ENCODE_PATH: undefined,
};

/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
/**
 * * `Critical` - CRITICAL
 * * `High` - HIGH
 * * `Medium` - MEDIUM
 * * `Low` - LOW
 */
var Priority;
(function (Priority) {
    Priority["CRITICAL"] = "Critical";
    Priority["HIGH"] = "High";
    Priority["MEDIUM"] = "Medium";
    Priority["LOW"] = "Low";
})(Priority || (Priority = {}));

/* generated using openapi-typescript-codegen -- do not edit */
/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
const isDefined = (value) => {
    return value !== undefined && value !== null;
};
const isString = (value) => {
    return typeof value === "string";
};
const isStringWithValue = (value) => {
    return isString(value) && value !== "";
};
const isBlob = (value) => {
    return (typeof value === "object" &&
        typeof value.type === "string" &&
        typeof value.stream === "function" &&
        typeof value.arrayBuffer === "function" &&
        typeof value.constructor === "function" &&
        typeof value.constructor.name === "string" &&
        /^(Blob|File)$/.test(value.constructor.name) &&
        /^(Blob|File)$/.test(value[Symbol.toStringTag]));
};
const isFormData = (value) => {
    return value instanceof FormData;
};
const isSuccess = (status) => {
    return status >= 200 && status < 300;
};
const base64 = (str) => {
    try {
        return btoa(str);
    }
    catch (err) {
        // @ts-ignore
        return Buffer.from(str).toString("base64");
    }
};
const getQueryString = (params) => {
    const qs = [];
    const append = (key, value) => {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
    };
    const process = (key, value) => {
        if (isDefined(value)) {
            if (Array.isArray(value)) {
                value.forEach((v) => {
                    process(key, v);
                });
            }
            else if (typeof value === "object") {
                Object.entries(value).forEach(([k, v]) => {
                    process(`${key}[${k}]`, v);
                });
            }
            else {
                append(key, value);
            }
        }
    };
    Object.entries(params).forEach(([key, value]) => {
        process(key, value);
    });
    if (qs.length > 0) {
        return `?${qs.join("&")}`;
    }
    return "";
};
const getUrl = (config, options) => {
    const encoder = config.ENCODE_PATH || encodeURI;
    const path = options.url
        .replace("{api-version}", config.VERSION)
        .replace(/{(.*?)}/g, (substring, group) => {
        var _a;
        if ((_a = options.path) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(group)) {
            return encoder(String(options.path[group]));
        }
        return substring;
    });
    const url = `${config.BASE}${path}`;
    if (options.query) {
        return `${url}${getQueryString(options.query)}`;
    }
    return url;
};
const getFormData = (options) => {
    if (options.formData) {
        const formData = new FormData();
        const process = (key, value) => {
            if (isString(value) || isBlob(value)) {
                formData.append(key, value);
            }
            else {
                formData.append(key, JSON.stringify(value));
            }
        };
        Object.entries(options.formData)
            .filter(([_, value]) => isDefined(value))
            .forEach(([key, value]) => {
            if (Array.isArray(value)) {
                value.forEach((v) => process(key, v));
            }
            else {
                process(key, value);
            }
        });
        return formData;
    }
    return undefined;
};
const resolve = async (options, resolver) => {
    if (typeof resolver === "function") {
        return resolver(options);
    }
    return resolver;
};
const getHeaders = async (config, options, formData) => {
    const [token, username, password, additionalHeaders] = await Promise.all([
        resolve(options, config.TOKEN),
        resolve(options, config.USERNAME),
        resolve(options, config.PASSWORD),
        resolve(options, config.HEADERS),
    ]);
    const formHeaders = (typeof (formData === null || formData === void 0 ? void 0 : formData.getHeaders) === "function" && (formData === null || formData === void 0 ? void 0 : formData.getHeaders())) || {};
    const headers = Object.entries({
        Accept: "application/json",
        ...additionalHeaders,
        ...options.headers,
        ...formHeaders,
    })
        .filter(([_, value]) => isDefined(value))
        .reduce((headers, [key, value]) => ({
        ...headers,
        [key]: String(value),
    }), {});
    if (isStringWithValue(token)) {
        headers["Authorization"] = `Bearer ${token}`;
    }
    if (isStringWithValue(username) && isStringWithValue(password)) {
        const credentials = base64(`${username}:${password}`);
        headers["Authorization"] = `Basic ${credentials}`;
    }
    if (options.body !== undefined) {
        if (options.mediaType) {
            headers["Content-Type"] = options.mediaType;
        }
        else if (isBlob(options.body)) {
            headers["Content-Type"] = options.body.type || "application/octet-stream";
        }
        else if (isString(options.body)) {
            headers["Content-Type"] = "text/plain";
        }
        else if (!isFormData(options.body)) {
            headers["Content-Type"] = "application/json";
        }
    }
    return headers;
};
const getRequestBody = (options) => {
    if (options.body) {
        return options.body;
    }
    return undefined;
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel, axiosClient) => {
    const source = axios.CancelToken.source();
    const requestConfig = {
        url,
        headers,
        data: body !== null && body !== void 0 ? body : formData,
        method: options.method,
        withCredentials: config.WITH_CREDENTIALS,
        withXSRFToken: config.CREDENTIALS === "include" ? config.WITH_CREDENTIALS : false,
        cancelToken: source.token,
    };
    onCancel(() => source.cancel("The user aborted a request."));
    try {
        return await axiosClient.request(requestConfig);
    }
    catch (error) {
        const axiosError = error;
        if (axiosError.response) {
            return axiosError.response;
        }
        throw error;
    }
};
const getResponseHeader = (response, responseHeader) => {
    if (responseHeader) {
        const content = response.headers[responseHeader];
        if (isString(content)) {
            return content;
        }
    }
    return undefined;
};
const getResponseBody = (response) => {
    if (response.status !== 204) {
        return response.data;
    }
    return undefined;
};
const catchErrorCodes = (options, result) => {
    var _a, _b;
    const errors = {
        400: "Bad Request",
        401: "Unauthorized",
        403: "Forbidden",
        404: "Not Found",
        500: "Internal Server Error",
        502: "Bad Gateway",
        503: "Service Unavailable",
        ...options.errors,
    };
    const error = errors[result.status];
    if (error) {
        throw new ApiError(options, result, error);
    }
    if (!result.ok) {
        const errorStatus = (_a = result.status) !== null && _a !== void 0 ? _a : "unknown";
        const errorStatusText = (_b = result.statusText) !== null && _b !== void 0 ? _b : "unknown";
        const errorBody = (() => {
            try {
                return JSON.stringify(result.body, null, 2);
            }
            catch (e) {
                return undefined;
            }
        })();
        throw new ApiError(options, result, `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`);
    }
};
/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @param axiosClient The axios client instance to use
 * @returns CancelablePromise<T>
 * @throws ApiError
 */
const request = (config, options, axiosClient = axios) => {
    return new CancelablePromise(async (resolve, reject, onCancel) => {
        try {
            const url = getUrl(config, options);
            const formData = getFormData(options);
            const body = getRequestBody(options);
            const headers = await getHeaders(config, options, formData);
            if (!onCancel.isCancelled) {
                const response = await sendRequest(config, options, url, body, formData, headers, onCancel, axiosClient);
                const responseBody = getResponseBody(response);
                const responseHeader = getResponseHeader(response, options.responseHeader);
                const result = {
                    url,
                    ok: isSuccess(response.status),
                    status: response.status,
                    statusText: response.statusText,
                    body: responseHeader !== null && responseHeader !== void 0 ? responseHeader : responseBody,
                };
                catchErrorCodes(options, result);
                resolve(result.body);
            }
        }
        catch (error) {
            reject(error);
        }
    });
};

class CommentService {
    /**
     * Create a new comment
     * Record a new comment that the user intends to add to a given task. This will save the comment in Dart for later access, search, etc.
     * @param requestBody
     * @returns WrappedComment Success, including the created comment
     * @throws ApiError
     */
    static createComment(requestBody) {
        return request(OpenAPI, {
            method: "POST",
            url: "/comments",
            body: requestBody,
            mediaType: "application/json",
            errors: {
                400: `Invalid request, including the errors`,
            },
        });
    }
}

class ConfigService {
    /**
     * Get user space configuration
     * Get information about the user's space, including all of the possible values that can be provided to other endpoints.
     * @returns UserSpaceConfiguration Success, including all of the options for the user space
     * @throws ApiError
     */
    static getConfig() {
        return request(OpenAPI, {
            method: "GET",
            url: "/config",
        });
    }
}

class DartboardService {
    /**
     * Retrieve an existing dartboard
     * Retrieve an existing dartboard. This will return the dartboard's information, including the title, description, all tasks within it, and others.
     * @param id
     * @returns WrappedDartboard Success, including the retrieved dartboard
     * @throws ApiError
     */
    static retrieveDartboard(id) {
        return request(OpenAPI, {
            method: "GET",
            url: "/dartboards/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Dartboard not found, including the errors`,
            },
        });
    }
}

class DocService {
    /**
     * Create a new doc
     * Record a new doc that the user intends to write down. This will save the doc in Dart for later access, search, etc. By default the created doc will be in the Docs folder. More information can be included in the text.
     * @param requestBody
     * @returns WrappedDoc Success, including the created doc
     * @throws ApiError
     */
    static createDoc(requestBody) {
        return request(OpenAPI, {
            method: "POST",
            url: "/docs",
            body: requestBody,
            mediaType: "application/json",
            errors: {
                400: `Invalid request, including the errors`,
            },
        });
    }
    /**
     * Retrieve an existing doc
     * Retrieve an existing doc. This will return the doc's information, including the title, folder, text and others.
     * @param id
     * @returns WrappedDoc Success, including the retrieved doc
     * @throws ApiError
     */
    static retrieveDoc(id) {
        return request(OpenAPI, {
            method: "GET",
            url: "/docs/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Doc not found, including the errors`,
            },
        });
    }
    /**
     * Update an existing doc
     * Update certain properties of an existing doc. This will save the doc in Dart for later access, search, etc. Any properties that are not specified will not be changed.
     * @param id
     * @param requestBody
     * @returns WrappedDoc Success, including the updated doc
     * @throws ApiError
     */
    static updateDoc(id, requestBody) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/docs/{id}",
            path: {
                id: id,
            },
            body: requestBody,
            mediaType: "application/json",
            errors: {
                400: `Invalid request, including the errors`,
                404: `Doc not found, including the errors`,
            },
        });
    }
    /**
     * Delete an existing doc
     * Move an existing doc to the trash, where it can be recovered if needed. Nothing else about the doc will be changed.
     * @param id
     * @returns WrappedDoc Success, including the deleted doc
     * @throws ApiError
     */
    static deleteDoc(id) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/docs/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Doc not found, including the errors`,
            },
        });
    }
    /**
     * List all docs that the user has access to. This will return a list of docs, including the title, folder, text and others.
     * @returns PaginatedConciseDocList
     * @throws ApiError
     */
    static listDocs({ folder, folderId, ids, inTrash, limit, o, offset, s, text, title, }) {
        return request(OpenAPI, {
            method: "GET",
            url: "/docs/list",
            query: {
                folder: folder,
                folder_id: folderId,
                ids: ids,
                in_trash: inTrash,
                limit: limit,
                o: o,
                offset: offset,
                s: s,
                text: text,
                title: title,
            },
        });
    }
}

class FolderService {
    /**
     * Retrieve an existing folder
     * Retrieve an existing folder. This will return the folder's information, including the title, description, all docs within it, and others.
     * @param id
     * @returns WrappedFolder Success, including the retrieved folder
     * @throws ApiError
     */
    static retrieveFolder(id) {
        return request(OpenAPI, {
            method: "GET",
            url: "/folders/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Folder not found, including the errors`,
            },
        });
    }
}

class TaskService {
    /**
     * Create a new task
     * Record a new task that the user intends to do. This will save the task in Dart for later access, search, etc. By default the created task will be assigned to the user, with a status of to-do, with no parent, in the Active dartboard. More information can be included in the description.
     * @param requestBody
     * @returns WrappedTask
     * @throws ApiError
     */
    static createTask(requestBody) {
        return request(OpenAPI, {
            method: "POST",
            url: "/tasks",
            body: requestBody,
            mediaType: "application/json",
        });
    }
    /**
     * Retrieve an existing task
     * Retrieve an existing task. This will return the task's information, including the title, dartboard, status, description and others.
     * @param id
     * @returns WrappedTask Success, including the retrieved task
     * @throws ApiError
     */
    static retrieveTask(id) {
        return request(OpenAPI, {
            method: "GET",
            url: "/tasks/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Task not found, including the errors`,
            },
        });
    }
    /**
     * Update an existing task
     * Update certain properties of an existing task. This will save the task in Dart for later access, search, etc. Any properties that are not specified will not be changed.
     * @param id
     * @param requestBody
     * @returns WrappedTask Success, including the updated task
     * @throws ApiError
     */
    static updateTask(id, requestBody) {
        return request(OpenAPI, {
            method: "PUT",
            url: "/tasks/{id}",
            path: {
                id: id,
            },
            body: requestBody,
            mediaType: "application/json",
            errors: {
                400: `Invalid request, including the errors`,
                404: `Task not found, including the errors`,
            },
        });
    }
    /**
     * Delete an existing task
     * Move an existing task to the trash, where it can be recovered if needed. Nothing else about the task will be changed.
     * @param id
     * @returns WrappedTask Success, including the deleted task
     * @throws ApiError
     */
    static deleteTask(id) {
        return request(OpenAPI, {
            method: "DELETE",
            url: "/tasks/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `Task not found, including the errors`,
            },
        });
    }
    /**
     * List all tasks that the user has access to. This will return a list of tasks, including the title, dartboard, status, description and others.
     * @returns PaginatedConciseTaskList
     * @throws ApiError
     */
    static listTasks({ assignee, assigneeId, dartboard, dartboardId, description, dueAtAfter, dueAtBefore, ids, inTrash, isCompleted, limit, offset, priority, size, startAtAfter, startAtBefore, status, statusId, tag, tagId, title, type, typeId, }) {
        return request(OpenAPI, {
            method: "GET",
            url: "/tasks/list",
            query: {
                assignee: assignee,
                assignee_id: assigneeId,
                dartboard: dartboard,
                dartboard_id: dartboardId,
                description: description,
                due_at_after: dueAtAfter,
                due_at_before: dueAtBefore,
                ids: ids,
                in_trash: inTrash,
                is_completed: isCompleted,
                limit: limit,
                offset: offset,
                priority: priority,
                size: size,
                start_at_after: startAtAfter,
                start_at_before: startAtBefore,
                status: status,
                status_id: statusId,
                tag: tag,
                tag_id: tagId,
                title: title,
                type: type,
                type_id: typeId,
            },
        });
    }
}

class ViewService {
    /**
     * Retrieve an existing view
     * Retrieve an existing view. This will return the view's information, including the title, description, all tasks within it, and others.
     * @param id
     * @returns WrappedView Success, including the retrieved view
     * @throws ApiError
     */
    static retrieveView(id) {
        return request(OpenAPI, {
            method: "GET",
            url: "/views/{id}",
            path: {
                id: id,
            },
            errors: {
                400: `Invalid request, including the errors`,
                404: `View not found, including the errors`,
            },
        });
    }
}

export { ApiError, CancelError, CancelablePromise, CommentService, ConfigService, DartboardService, DocService, FolderService, OpenAPI, Priority, TaskService, ViewService };
